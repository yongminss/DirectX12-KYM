- 21.01.13
1. DirectX로 프로젝트를 만들기 위해서는 Device를 생성 및 초기화 해야 함
-> Direct3D를 사용하려면 DXGI를 걸쳐야 함 - DXGI는 Direct3D를 사용하기 위한 라이브러리
2. __uuid 연산자 : 연결된 UUID 값을 가져올 때 사용하는 확장 연산자
-> 대표적으로 COM 객체를 정의하는 구문에서 볼 수 있음 (ex. __uuidof (IDXGIFactory4))

- 21.01.14
1. #pragma comment(lib, "dxgi.lib") - CreateDXGIFactory 함수를 사용하기 위해 필요
-> #include <dxgi1_4.h> 뿐만 아니라 #pragma comment(lib, "dxgi.lib") 도 필요함
2. Factory를 생성했으니 이를 이용하여 그래픽 어댑터를 열거 - 12.0 레벨 지원하는 디바이스
-> 만약 열거하는 과정에서 실패하면 11.0 레벨을 지원하는 디바이스로 생성

- 21.01.15
1. Device를 생성했으므로 CommandQueue와 CommandList를 생성해야 함
-> CommandQueue - 큐 형태로 동작하는 COM 객체, CommandList - 명령을 담고 있음
 -> CommandQueue에 여러 개의 CommandList를 담고 명령을 GPU에 제출 (GPU가 실행)
-> CommandAllocator - GPU 명령을 저장하기 위한 메모리를 할당하는 COM 객체
-> CommandList - 내부에 있는 함수는 Set과 Draw -> 만들기 위해선 CommandAllocator
-> Command는 Excute를 통해 큐에 명령을 담음 (바로 실행 x, 큐에 명령을 집어 넣는 것)
-> 추가한 명령을 실행하려면 CommandList를 Close()하고 Excute를 호출해야 함

- 21.01.18~19
1. DirectX의 Double Buffering : 플리핑으로 구현 - 전면 버퍼와 후면 버퍼를 교체 (하드웨어)
-> 전면 버퍼는 모니터와 직접 연결되고 그래픽 카드만 접근 가능한 영역
-> 후면 버퍼는 응용 프로그램이 그래픽 작업을 하는 영역 (=우리가 렌더링하는 영역)
2. SwapChain 생성 - 스왑 체인을 생성하기 전에 다중 샘플링을 위한 품질 지원 검사 필요
-> SwapChain의 Present를 호출하면 후면 버퍼와 전면 버퍼의 교체가 발생

- 21.01.20, 21.01.25
1. CPU와 GPU가 병렬적으로 동작하기 위해 동기화 필요 - CPU는 리소스 생성, GPU는 사용
-> CPU : 렌더링에 필요한 모든 데이터를 ID3D12Resource COM 객체에 저장 (버퍼들)
-> n번째 렌더링 데이터를 GPU가 실행하지 않았을 때, CPU가 n+1번째 프레임 렌더링 데이터
 -> 삽입하려고 하면 GPU와 동기화 문제 발생 - n번째가 GPU에서 처리된 후 삽입되어야 함
-> 즉, CPU가 데이터를 넣으려면 GPU의 렌더링 작업이 끝나야 함 - Fence를 통해 구현
-> FenceValue : 프레임 번호, 매 프레임마다 값이 증가되고 값이 1이 될 때까지 CPU 대기
 -> GPU가 모든 렌더링 처리를 끝내면 값을 증가시켜 CPU가 동작할 수 있게 함
-> Signal() : Fence 값이 원하는 값으로 도달될 때 통지를 받음 (ex. value가 0에서 1로 상승)
 -> 현재 프로젝트에서는 OS를 통해 이벤트로 Fence 값을 확인할 것임 - 주기적인 확인 x
-> Event : WinAPI가 제공하는 동기화 오브젝트 - Event가 오면 true로 값이 바뀌게 됨
 -> GPU가 현재 Fence 지점에 도착하면 이벤트를 발동하여 CPU-GPU 동기화를 구현
 -> CommandQueue의 Wait() 함수로 기다리지 않고 WinAPI가 제공하는 Wait 함수를 사용

- 21.01.26
1. 리소스 : 셰이더로 넘겨주는 모든 데이터 (=GPU가 사용하는 데이터)
-> 텍스쳐(이미지, 그림)와 버퍼(그림이 아닌 데이터 ex. 행렬, 벡터 등)로 구분
2. 리소스 뷰 : 리소스를 어떻게 사용할 것인지를 정의 - 리소스의 포인터 정보가 있음
-> DirectX 12의 셰이더 프로그램은 리소스를 직접 넘겨받지 않고 뷰를 통해 넘겨받아 사용
-> 종류 : 용도에 따라 세분화 (ex. 상수 버퍼 뷰, 무순서화 접근 뷰, 랜더 타겟 뷰 등)
-> 뷰를 Set 하기 위해선 먼저 리소스를 생성해야 함 -> 생성 후, 리소스에 대한 뷰 생성
3. 리소스 생성 : ID3D12Device 객체가 가지고 있는 CreateCommittedResource()로 생성
-> DirectX 12의 모든 리소스는 ID3D12Resource COM 객체에 만들어짐
-> 이 때, 반환되는 인터페이스 포인터 주소는 물리적인 주소가 아닌 가상 메모리 주소
-> CreateCommittedResource() 함수를 통해 리소스를 만들면 물리적 메모리에도 미리 할당
 -> 커밋 리소스는 가상 + 물리적 메모리를 둘 다 생성하여 1:1로 대응 - 공간 부족 문제 주의
4. 서술자 (Descriptor) : 뷰를 Set 하기 위해 필요 - 리소스를 GPU가 사용하기 위한 연결체
-> 리소스는 가상 메모리에 만들어짐 - 주소가 바뀔 수 있어 CPU, GPU에 직접 맡기면 안됨
-> 이를 관리하기 위한 중간 매개체가 서술자 (=리소스 가상 메모리 포인터를 관리)
-> 서술자 힙은 모든 서술자들에 대한 테이블(=배열), 여기에 리소스 뷰를 채워 넣음
-> 서술자 힙을 생성할 때는 리소스 뷰의 타입에 맞게 생성해야 함 (ex. CBV, RTV, DSV 등)
* 리소스를 사용하기 위해선 1. 서술자 힙, 2. 힙 타입에 맞는 뷰, 3. 리소스가 필요

- 21.02.01
1. RenderTarget Buffer와 Depth-Stencil Buffer를 사용하기 위해 서술자 힙을 생성
-> 서술자 힙은 가상 메모리로 만들어진 리소스의 메모리를 중간에서 관리하는 매개체 역할
2. 서술자 힙에 사용할 각각의 리소스 뷰 생성 -> 리소스 뷰를 생성하기 이전에 리소스 필요
-> RenderTarget은 만들어둔 SwapChain을 사용하고, Depth-Stencil은 리소스를 따로 생성
3. 리소스 힙 - CPU는 디폴트 힙에 접근 불가, 리소스를 만드려면 추가적인 리소스 힙 필요
-> 업로드 힙 : CPU가 접근 가능하고 GPU도 읽고 쓰기가 가능 - CPU가 리소스를 write
-> 즉, 디폴트 힙에 리소스를 만들기 위해서는 CPU가 접근할 수 있는 업로드 힙이 필요함
-> CommandList의 CopyResource() 함수로 GPU 메모리에 있는 내용을 복사할 수 있음
 -> Copy를 하면, 업로드 힙의 내용이 디폴트 힙에 복사됨 (단, 내용이 바로 옮겨지진 않음)
 -> 복사가 되는 시점은 Queue에서 실행될 때 이므로 이를 유의해야 함
-> Depth-Stencil Buffer는 CPU에서 따로 write할 내용이 없으므로 업로드 힙은 필요 없음

- 21.02.02
1. 리소스 장벽 : 리소스에 대한 상태 관리를 위한 객체 - 읽고 쓰기의 동시 동작을 방지
-> 어떤 그래픽 명령이 리소스를 사용해 실행되려면 리소스는 명령에 맞는 상태이어야 함
 -> ex. 스왑 체인의 후면 버퍼는 GPU 입장에서 렌더타겟에 쓰기 연산을 수행 - WRITE 상태
 -> Present를 하면 읽기 연산으로 바뀜 - READ 상태, 리소스의 상태가 변경됨
