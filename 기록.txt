- 21.01.13
1. DirectX로 프로젝트를 만들기 위해서는 Device를 생성 및 초기화 해야 함
-> Direct3D를 사용하려면 DXGI를 걸쳐야 함 - DXGI는 Direct3D를 사용하기 위한 라이브러리
2. __uuid 연산자 : 연결된 UUID 값을 가져올 때 사용하는 확장 연산자
-> 대표적으로 COM 객체를 정의하는 구문에서 볼 수 있음 (ex. __uuidof (IDXGIFactory4))

- 21.01.14
1. #pragma comment(lib, "dxgi.lib") - CreateDXGIFactory 함수를 사용하기 위해 필요
-> #include <dxgi1_4.h> 뿐만 아니라 #pragma comment(lib, "dxgi.lib") 도 필요함
2. Factory를 생성했으니 이를 이용하여 그래픽 어댑터를 열거 - 12.0 레벨 지원하는 디바이스
-> 만약 열거하는 과정에서 실패하면 11.0 레벨을 지원하는 디바이스로 생성

- 21.01.15
1. Device를 생성했으므로 CommandQueue와 CommandList를 생성해야 함
-> CommandQueue - 큐 형태로 동작하는 COM 객체, CommandList - 명령을 담고 있음
 -> CommandQueue에 여러 개의 CommandList를 담고 명령을 GPU에 제출 (GPU가 실행)
-> CommandAllocator - GPU 명령을 저장하기 위한 메모리를 할당하는 COM 객체
-> CommandList - 내부에 있는 함수는 Set과 Draw -> 만들기 위해선 CommandAllocator
-> Command는 Excute를 통해 큐에 명령을 담음 (바로 실행 x, 큐에 명령을 집어 넣는 것)
-> 추가한 명령을 실행하려면 CommandList를 Close()하고 Excute를 호출해야 함

- 21.01.18~19
1. DirectX의 Double Buffering : 플리핑으로 구현 - 전면 버퍼와 후면 버퍼를 교체 (하드웨어)
-> 전면 버퍼는 모니터와 직접 연결되고 그래픽 카드만 접근 가능한 영역
-> 후면 버퍼는 응용 프로그램이 그래픽 작업을 하는 영역 (=우리가 렌더링하는 영역)
2. SwapChain 생성 - 스왑 체인을 생성하기 전에 다중 샘플링을 위한 품질 지원 검사 필요
-> SwapChain의 Present를 호출하면 후면 버퍼와 전면 버퍼의 교체가 발생

- 21.01.20
1. CPU와 GPU가 병렬적으로 동작하기 위해 동기화 필요 - CPU는 리소스 생성, GPU는 사용
-> CPU : 렌더링에 필요한 모든 데이터를 ID3D12Resource COM 객체에 저장 (버퍼들)
-> n번째 렌더링 데이터를 GPU가 실행하지 않았을 때, CPU가 n+1번째 프레임 렌더링 데이터
 -> 삽입하려고 하면 GPU와 동기화 문제 발생 - n번째가 GPU에서 처리된 후 삽입되어야 함
-> 즉, CPU가 데이터를 넣으려면 GPU의 렌더링 작업이 끝나야 함 - Fence를 통해 구현
-> FenceValue : 프레임 번호, 매 프레임마다 값이 증가되고 값이 1이 될 때까지 CPU 대기
 -> GPU가 모든 렌더링 처리를 끝내면 값을 증가시켜 CPU가 동작할 수 있게 함
